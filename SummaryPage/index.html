<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href=styles.css>

    <title>About us | Focus Zoo</title>

</head>

<body>

<header>
    <h1>Focus Zoo</h1>
    <p>die Chrome-Extension die dir beim Lernen hilft</p>
</header>

<main>
    <div class="content-wrapper">

        <section>
            <h2>Focus Zoo</h2>
            <h3>Einleitung</h3>
            <p>
                In der IT-Welt gibt es kaum jemanden, der noch nie eine Browser-Extension verwendet hat.
                Wir, das Projektteam, hatten noch keine Erfahrung mit Chrome Extensions, aber ein starkes Interesse zu
                lernen,
                wie diese im Hintergrund funktionieren und implementiert werden.
            </p>

            <h3>Projektidee</h3>
            <p>
                Alle Student*innen kennen das Problem, dass sie am Laptop arbeiten möchten, aber Ablenkungen wie Youtube
                oder Instagram nur einen Klick entfernt sind.
                Aufbauend auf die Pomodoro Technik, nach der in 25 Minuten-Zyklen gelernt wird, bietet die
                Chrome-Extension Timer-Funktionalitäten.
                Nach abgelaufenem Timer werden dabei Rewards in Form von Tieren freigeschaltet, um eine zusätzliche
                Lern-Motivation bereitzustellen.
                Während einem Lernzyklus werden dabei benutzerdefinierte Seiten blockiert, falls man durch die Macht der
                Gewohnheit doch einmal auf Social-Media Seiten abdriftet.
            </p>
        </section>

        <section>
            <h2>Features</h2>
            <h3>Startseite</h3>
            <p>Die Startseite öffnet sich nach der Installation der Chrome Extension und beschreibt die Idee des
                Projekts.</p>
            <img src="./img/index_light.png" alt="image of index-page" class="image">
            <img src="./img/index_dark.png" alt="image of index-page in dark mode" class="image">
            <h3>Timer</h3>
            <p>Auf der Timer-Seite können Timer gestartet und gestoppt werden. Läuft ein Timer, sieht man eine Animation
                der noch verbleibenden Zeit.</p>
            <img src="./img/timer_light.png" alt="image of timer-page" class="image">
            <img src="./img/timerRunning_light.png" alt="image of timer running" class="image">
            <br>
            <img src="./img/timer_dark.png" alt="image of timer-page in dark mode" class="image">
            <img src="./img/timerRunning_dark.png" alt="image of timer running in dark mode" class="image">
            <h3>Statistics</h3>
            <p>Die Statistik-Seite zeigt bereits absolvierte Timer, inklusive Datum und freigeschaltetem Tier.</p>
            <img src="./img/statistics_light.png" alt="image of statistics-page" class="image">
            <img src="./img/statistics_dark.png" alt="image of statistics-page in dark mode" class="image">
            <h3>Zoo</h3>
            <p>Im Zoo sieht man, welche Tiere schon freigeschaltet wurden.</p>
            <img src="./img/collection_light.png" alt="image of zoo-page" class="image">
            <img src="./img/collection_dark.png" alt="image of zoo-page in dark mode" class="image">
            <h3>Authors</h3>
            <p>Die Autoren-Seite zeigt das Projektteam.</p>
            <img src="./img/authors_light.png" alt="image of authors-page" class="image">
            <img src="./img/authors_dark.png" alt="image of authors-page in dark mode" class="image">
            <h3>Dev-Tools</h3>
            <p>Die Dev-Tools ermöglichen das einfügen von abgeschlossenen Timern, um die Funktionalität präsentieren zu
                können.</p>
            <img src="./img/devTools_light.png" alt="image of dev-tools-page" class="image">
            <img src="./img/devTools_dark.png" alt="image of dev-tools-page in dark mode" class="image">
            <h3>Blocked Pages Management</h3>
            <p>Auf dieser Seite kann man verwalten, welche Seiten bei laufenden Timern blockiert werden sollen.</p>
            <img src="./img/blocked_light.png" alt="image of blocked-page" class="image">
            <img src="./img/blocked_dark.png" alt="image of blocked-page in dark mode" class="image">
            <h3>Blocked Social Media Pages</h3>
            <p>Hier sieht man was passiert, wenn Seiten bei laufenden Timern blockiert werden. Dabei wird der Inhalt der
                Seite überschreiben und der Timer angezeigt.</p>
            <img src="./img/blockedOverride_light.png" alt="image of override of social media" class="image">
            <img src="./img/blockedOverride_dark.png" alt="image of override of social media in dark mode"
                 class="image">
        </section>

        <section>
            <h2>Installationsanleitung</h2>
            <p>1. Verwaltung der Chrome Extensions aufrufen: chrome://extensions/</p>
            <p>2. Auf "Entpackte Erweiterung laden" klicken und das Projekt Focus Zoo auswählen</p>
            <p>3. Fertig! Jetzt kann die Extension jederzeit über das Puzzle-Symbol geöffnet werden</p>
            <p> HIER zum Download: <a href="https://github.com/PichlerMathias/WDP_Chrome_Extension">Github-Repo</a>. Die
                Erweiterung befindet sich in /WDP_Chrome_Extension/FocusZoo</p>
        </section>

        <section>
            <h2>Implementierung</h2>
            <h3>manifest.json</h3>
            <p>
                Eine Chrome Extension ist eine ganz normale Webseite. Der einzige Unterschied ist ein eigenes
                manifest.json File, in dem Einstellungen wie Name, App-Icon etc. festgelegt wird.
            </p>
            <details>
                <summary><b>Codebeispiel manifest.json</b></summary>
                <pre>
            <code>
{
  "name": "Focus Zoo",
  "version": "0.0.1",
  "description": "This extension helps you to stay focussed while building you own zoo",
  "icons": {
    "16": "images/camel16.png",
    "48": "images/camel48.png",
    "128": "images/camel128.png"
  },
  "manifest_version": 3,
  "action": {
    "default_popup": "pages/index/index.html",
    "default_title": "Focus Zoo"
  },
  "permissions": [
    "storage"
  ],
  "background": {
    "service_worker": "db/service_worker.js",
    "type": "module"
  },
  "content_scripts": [
    {
      "matches": [
        "<<!---->all_urls>"
      ],
      "js": [
        "pages/blocked_override/blocked_override.js"
      ]
    }
  ],
  "web_accessible_resources": [
    {
      "resources": [
        "pages/timer/clock.js",
        "db/database.js",
        "db/countdown.js",
        "db/websites.js"
      ],
      "matches": [
        "<<!---->all_urls>"
      ]
    }
  ]
}</code>
            </pre>
            </details>

            <h3>Datenbanken</h3>
            <p>
                Damit die freigeschalteten Tiere und laufenden Timer immer gespeichert werden, muss auch eine Datenbank
                verwendet werden.
            </p>

            <p>Tabellen:</p>
            <ul>
                <li><p>animals: Speichert freigeschaltete Tiere</p></li>
                <li><p>countdowns: Speichert abgeschlossene Countdowns</p></li>
                <li><p>Websites: Speichert blockierte Seiten</p></li>
            </ul>

            <p>
                Für gespeicherte Daten innerhalb der Extension wird dabei eine IndexedDB verwendet.
                Um auf externen Seiten Zugriff auf die Datenbank zu ermöglichen, werden Tabellen wie websites im
                Chrome-Local-Storage gespeichert, weil die IndexedDB nur innerhalb der Extension verfügbar ist.
            </p>

            <details>
                <summary><b>Codebeispiel IndexedDB: Einfügen und Lesen der absolvierten Countdowns</b></summary>
                <pre>
                <code>
// gets finished countdowns from database
export function getAllCountdowns(callback) {
    const request = indexedDB.open('zooDb');

    request.onsuccess = function (event) {
        const db = event.target.result;
        const transaction = db.transaction('countdowns', 'readonly');
        const objectStore = transaction.objectStore('countdowns');
        const getAllRequest = objectStore.getAll();

        getAllRequest.onsuccess = function (event) {
            const countdowns = event.target.result;

            if (countdowns.length > 0) {
                callback(countdowns);
            } else {
                callback([]);
            }

            db.close();
        };

        getAllRequest.onerror = function (event) {
            console.error("Error getting all countdowns:", event.target.error);
            callback([]);
            db.close();
        };
    };

    request.onerror = function (event) {
        console.error("Error opening database:", event.target.error);
        callback([]);
    };
}

// creates a new countdown
export function insertCountDown(date, length) {

    getLockedAnimalIds(function (lockedAnimalIds) {

        const request = indexedDB.open('zooDb');

        request.onsuccess = function (event) {
            const db = event.target.result;
            const transaction = db.transaction(['countdowns'], 'readwrite');
            const objectStore = transaction.objectStore('countdowns');

            let animalId = lockedAnimalIds[Math.floor(Math.random() * lockedAnimalIds.length)];

            const countdownRecord = {
                date: date,
                length: length,
                animalId: animalId
            };

            const addRequest = objectStore.add(countdownRecord);

            addRequest.onsuccess = function () {
                console.log('Countdown inserted successfully');
            };

            addRequest.onerror = function (event) {
                console.error('Error inserting countdown:', event.target.error);
            };
        };


    });
}
                </code>
                </pre>
            </details>

            <details>
                <summary><b>Codebeispiel chrome.storage.local: Verwalten der blockierten Webseiten</b>
                </summary>
                <p>Die Daten werden als Key-Value Pair gespeichert. Dabei wird für die Liste der Webseiten ein Json-String verwendet.</p>
                <pre>
                <code>
export function setWebsiteList(websiteList, callback) {
    chrome.storage.local.set({webSiteListName: JSON.stringify(websiteList)}, function () {
        callback(null);
    });
}

export function getWebsiteList(callback) {
    chrome.storage.local.get({webSiteListName}, function (data) {
        try {
            let json = JSON.parse(data.webSiteListName);
            callback(json);
        } catch (error) {
            if (error instanceof SyntaxError) {
                callback(null);
            }
            else {
                throw error;
            }
        }
    });
}

export function addWebsite(website, callback) {
    getWebsiteList(function (retrievedList) {
        retrievedList.push(website);
        setWebsiteList(retrievedList, function () {
            callback();
        });
    })
}

export function removeWebsite(website, callback) {
    getWebsiteList(function (retrievedList) {

        const updatedList = retrievedList.filter(item => item !== website);
        setWebsiteList(updatedList, function () {
            callback();
        });
    });
}
                </code>
                </pre>
            </details>

            <h3>Blockieren von Webseiten</h3>
            <p>
                Um Seiten zu "blockieren" wird der eigentliche Inhalt der Webseite überschrieben.
                Nach der Überprüfung, ob die aktuelle Seite unter der Liste von blockierten Seiten ist,
                wird der HTML-Code mit dem ablaufenden Timer überschrieben. Hier hat man auch die Möglichkeit,
                den Timer abzubrechen oder die Seite zu entblockieren.
            </p>

            <details>
                <summary><b>Codebeispiel: Aufrufen von Code auf externen Webseiten</b></summary>
                <p>In der Datei manifest.json kann festgelegt werden, wann welcher Code aufgerufen werden soll.
                In diesem Fall rufen wir auf allen Seiten (all_urls) den Code in blocked_override.js auf. Dieser wird im nächsten Codebeispiel gezeigt.</p>
                <pre>
                <code>
  "content_scripts": [
    {
      "matches": [
        "<<!---->all_urls>"
      ],
      "js": [
        "pages/blocked_override/blocked_override.js"
      ]
    }
  ],
  "web_accessible_resources": [
    {
      "resources": [
        "pages/timer/clock.js",
        "db/database.js",
        "db/countdown.js",
        "db/websites.js"
      ],
      "matches": [
        "<<!---->all_urls>"
      ]
    }
  ]
                </code>
                </pre>
            </details>
            <details>
                <summary><b>Codebeispiel: Überschreiben von Blockierten Seiten in blocked_override.js</b></summary>
                <pre>
                <code>
// function that overrides the content of the blocked page with a timer and the option to cancel the timer or unblock the website
(async () => {
    const websitesScript = await import(chrome.runtime.getURL('./db/websites.js'));
    const clockScript = await import(chrome.runtime.getURL('./pages/timer/clock.js'));

    websitesScript.getWebsiteList(function (forbiddenSites) {
        const hostname = window.location.hostname;

        let forbidden = false;

        forbiddenSites.forEach((site) => {
                if (hostname.includes(site)) {
                    forbidden = true;
                }
            }
        );

        if (forbidden) {
            clockScript.getRemainingSeconds(function (remainingSeconds) {
                if (remainingSeconds > 0) {
                    document.head.innerHTML = blockedHead;
                    document.body.innerHTML = blockedBody;

                    let cancel = document.getElementById("cancel");
                    cancel.addEventListener("click", function () {
                        clockScript.cancelClock();
                        location.reload();
                    });

                    let deblock = document.getElementById("deblockWebsite");
                    deblock.addEventListener("click", function () {
                        console.log("Try to deblock site: ");
                        websitesScript.removeWebsiteContaining(hostname, function (){
                            location.reload();
                        });
                    });

                    clockScript.initClock(function (timerIsRunning) {
                        console.log("timerIsRunning: ", timerIsRunning);
                        if (timerIsRunning) {
                            clockScript.getRemainingSeconds(function (remainingSeconds, limit) {
                                clockScript.startClock(remainingSeconds, limit, () => location.reload());
                            });
                        }

                    })

                }
            });
        }

    });
})();
                </code>
                </pre>
            </details>
        </section>

        <section>
            <h2>Lessons learned</h2>
            <h3>Arbeiten mit Chrome Extensions</h3>
            <p>
                Es war sehr überraschend, wie einfach Chrome Extensions erstellt werden können. Für
                jeden mit Interesse kann das Experimentieren mit Chrome Extensions auf jeden Fall empfohlen werden.
            </p>
            <p>
                Im Gegensatz zu normalen Seiten gibt es aber in Chrome Extensions einige Limitierungen aus Sicherheitsgründen.
                Es dürfen zum Beispiel keine Dateien als Links importiert werden. Dadurch müsste zum Beispiel Bootstrap heruntergeladen werden und kann nicht als Link eingebunden werden.
            </p>
            <p>
                Außerdem darf in html-Dateien kein Javascript-Code verwendet werden. Das heißt, dass alle Javascript-Zeilen in eigenen js-Files stehen und importiert werden müssen.
            </p>

            <h3>Arbeiten als Team</h3>
            <p>
                Vorhandene GIT-Vorkenntnisse haben das gemeinsame Arbeiten deutlich vereinfacht. Dabei wurde für
                jede Änderung ein eigener Merge Request angelegt, um eine gute Code-Qualität garantieren zu können.
                Bevor ein Feature endgültig fertiggestellt wurde, ist es von beiden Personen abgenommen worden.
                Dadurch konnten Fehler verhindert und die Qualität des Codes sichergestellt werden.
            </p>

            <h3>Vorgangsweise und Arbeitsteilung</h3>
            <p>
                Während Mathias Pichler schon früh mit dem Grunddesign und der Backendprogrammierung begann,
                übernahm Mariella Wildauer danach die Feingliederung des Inhaltes inklusive Design.
                Diese Vorgangsweise ermögliche es, kaum Konflikte im Code zu erzeugen. Dies führte zu einer schnellen
                Implementierung des Projektes.

                Außerdem wurde bereits zu Beginn in <a href="https://www.notion.so/product">Notion</a> ein einfaches
                Ticket-System aufgesetzt, womit die Arbeit strukturiert und übersichtlich dargestellt wurde.
            </p>
            <img src="./img/tickets.png" alt="Tickets in notion" class="image">


        </section>

        <section>
            <h2>Links und Ressourcen</h2>
            <h3>Tier-Images</h3>
            <p>
                Die Bilder stammen von <a href="https://iconduck.com/?redirect">Iconduck</a> und sind für
                kommerzielle Nutzung freigegeben.
            </p>

            <h3>Blockieren von Webseiten</h3>
            <p><a href="https://www.youtube.com/watch?v=dIrXIJ781DQ">@PedroTech</a> erklärt in seinem Youtube-Video, wie man Code auf externen Webseiten ausführen kann, um dort den Inhalt zu überschreiben.
            </p>

            <h3>Design</h3>
            <p>Die Farbpalette wurde auf
            <a href="https://paletton.com/#uid=70k0u0kjgtC9oMeeHAmnfq4qPlj">Paletton.com</a>
            ausgewählt. </p>

            <h3>IndexedDB</h3>
            <p>Die Folgenden Blogs zeigen das Arbeiten mit einer IndexedDB</p>
            <ul>
                <li><a href="https://web.dev/articles/indexeddb?hl=de#:~:text=IndexedDB%20is%20a%20low%2Dlevel,larger%20amounts%20of%20structured%20data.">web.dev</a></li>
                <li><a href="https://blog.logrocket.com/using-indexeddb-complete-guide/">logrocket.com</a></li>
            </ul>

            <h3>Chrome Local Storage</h3>
            <p>@Paula Santamaria schreibt in Ihrem Blog über den Chrome Local Storage: <a href="https://dev.to/paulasantamaria/chrome-extensions-local-storage-1b34">dev.to</a></p>

        </section>

        <h2>Projektteam</h2>
        <section class="authors-section">
            <div class="author">
                <img src="./img/Mathias.jpeg" alt="image of Mathias Pichler" class="image">
                <h2>Mathias Pichler</h2>
                <p></p>
            </div>

            <div class="author">
                <img src="./img/Mariella.jpeg" alt="image of Mariella Wildauer" class="image">
                <h2>Mariella Wildauer</h2>
                <p></p>
            </div>
        </section>

    </div>
</main>


<footer>
    <p>
        © Mathias Pichler & Mariella Wildauer
    </p>
</footer>

</body>

</html>